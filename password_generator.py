# password_generator.py by Thomas Nisterenko

import secrets
import string
from LinkStack import LinkStack

# constants
DEF_MIN_LEN = 8
DEF_MAX_LEN = 18
ZERO = 0
ONE = 1
CHAR_POOL = string.ascii_letters + string.digits + string.punctuation
EMPTY = ""


def generate_password():
    """
    Generates a password with use of the secrets module functionality.
    This function contains other function calls that allow users to set
    preferences for their password.

    :return password: string representing the password
    """

    print("Welcome to the password generator! The program will ask for some of "
          "your preferences before generating a random password.\nATTENTION: "
          "Do not use the passwords generated by this program in sensitive/"
          "private accounts.")
    print()

    # gets the password length
    pass_length = set_length()
    print()

    # rem_length is used to make sure that the constraints given for minimum
    # numeric, special, and uppercase characters are valid
    rem_length = pass_length

    # min_nums gets the minimum amount of numeric characters that the password
    # must have (rem_length is updated)
    min_nums, rem_length = set_min_nums(rem_length)
    print()
    # min_specials gets the minimum amount of special characters that the
    # password must have (rem_length is updated)
    min_specials, rem_length = set_min_specials(rem_length)
    print()
    # min_upper gets the minimum amount of uppercase letters that the password
    # must have (rem_length is updated)
    min_upper, rem_length = set_min_upper(rem_length)
    print()
    # max_repetitions gets the maximum amount of back to back repeated
    # characters tolerated
    max_repetitions = set_repetition_preference(pass_length)
    print()
    # invalid gets a string containing all characters that should not be in
    # the password
    invalid = set_invalid_chars(pass_length, max_repetitions)

    # rep_stack is used to keep track of the back to back repeated characters
    rep_stack = LinkStack()

    # while True loop guarantees that the function only terminates when a
    # password is generated
    while True:

        # variables that are 'reset' every iteration of the while loop
        password = ""
        i = ZERO
        nums_amount = ZERO
        specials_amount = ZERO
        upper_amount = ZERO

        # rep_stack is always cleared when starting over
        rep_stack.remove_all()

        # while loop that is responsible for creating a password
        while i < pass_length:

            # a single character is picked from the character pool
            curr_char = secrets.choice(CHAR_POOL)

            if curr_char not in invalid:
                # if rep_stack is empty or if curr_char is already in it (back-
                # to-back repetition), curr_char is pushed to rep_stack
                if rep_stack.is_empty() or curr_char == rep_stack.top():
                    rep_stack.push(curr_char)
                # otherwise, repetition must be 'reset' so rep_stack is cleared
                # and curr_char becomes the new repetition signal
                else:
                    rep_stack.remove_all()
                    rep_stack.push(curr_char)

                # in order to add the character to password, rep_stack must not
                # have more than the acceptable amount of consecutive repeated
                # characters
                if len(rep_stack) <= max_repetitions + ONE:

                    # if-elif-elif block simply counts whether the character
                    # is a uppercase, digit/numeric or special/punctuation
                    if curr_char in string.ascii_uppercase:
                        upper_amount += ONE
                    elif curr_char in string.digits:
                        nums_amount += ONE
                    elif curr_char in string.punctuation:
                        specials_amount += ONE

                    # curr_char is added to password and only then is the
                    # loop control incremented
                    password += curr_char
                    i += ONE

        # finally, in order to terminate the loop, the password must have
        # the minimum required amounts of numeric, special, and uppercase
        # characters
        if nums_amount >= min_nums and specials_amount >= min_specials and \
                upper_amount >= min_upper:
            print("Password:", password)
            print("Length:", pass_length, "characters.")
            print("Contains: {} number(s), {} special character(s), and {} "
                  "uppercase letter(s).".format(nums_amount, specials_amount,
                                                upper_amount))

            print()
            print("Thank you for using the password generator!")
            return password


def set_length():
    """
    This function asks user for input concerning their preference for password
    length. The user can choose not to specify length preferences in which
    case, a password will have length between 8 and 18 characters.

    :return length: integer representing the length of the password
    """

    print("Please input a minimum length for your password. Alternatively, "
          "press ENTER to use default of {} characters.".format(DEF_MIN_LEN))

    # gets the minimum length that the password can be
    min_len = get_preference(DEF_MIN_LEN)

    print()

    print("Please input a maximum length for your password. Alternatively, "
          "press ENTER to use default of {} characters.".format(DEF_MAX_LEN))

    # gets the maximum length that the password can be
    max_len = get_preference(DEF_MAX_LEN)

    # raises an Exception if mas and min lengths are incompatible
    if max_len < min_len:
        raise Exception("ERROR: Maximum length cannot be less than minimum "
                        "length!")

    # randomly picks a length considering min and max lengths
    length = secrets.choice(range(min_len, max_len + ONE))
    print()
    print("A password containing", length, "characters will be generated.")

    return length


def set_repetition_preference(pass_length):
    """
    Allows users to set their preference regarding repeated characters occurring
    back to back in the password.

    :param pass_length: integer representing length of password
    :return repeat_limit: integer representing how many characters can be
                          repeated back to back. Defaults to pass_length
    """

    print("Please input how many repeated back-to-back characters are "
          "tolerable."
          "\n(The same character may appear more than once in the password "
          "regardless). Alternatively, press ENTER to not set a limit on "
          "repetition.")

    repeat_limit = get_preference(pass_length)

    print("\nMaximum back-to-back characters in a sequence:", repeat_limit)
    return repeat_limit


def set_min_nums(rem_length):
    """
    Sets the minimum amount of numeric characters that the password must have.

    :param rem_length: integer representing the remaining length of the password
    :return min_nums: integer representing the minimum amount of numeric
                      characters in the password
    :return rem: integer representing remaining length of password after
                 minimum number of numeric characters are taken into account
    """

    print("Please input the minimum amount of numeric characters that your "
          "password must contain. Alternatively, press ENTER to indicate a "
          "minimum of 1 numeric character.")

    # gets the minimum amount of numeric characters and how many characters
    # remain after considering them
    min_nums, rem = set_min_amt(rem_length)

    print("\nMinimum numeric character(s) that the password will contain:",
          min_nums)
    print("You have", rem, "character(s) remaining in the password.")

    return min_nums, rem


def set_min_specials(rem_length):
    """
    Sets the minimum amount of special characters that the password must have.

    :param rem_length: integer representing the remaining length of the password
    :return min_specials: integer representing the minimum amount of special
                          characters in the password
    :return rem: integer representing remaining length of password after
                 minimum number of special characters are taken into account
    """

    print("Please input the minimum amount of special characters that your "
          "password must contain. Alternatively, press ENTER to indicate a "
          "minimum of 1 special character.")

    # gets the minimum amount of special characters and how many characters
    # remain after considering them
    min_specials, rem = set_min_amt(rem_length)

    print("\nMinimum special character(s) that the password will contain:",
          min_specials)
    print("You have", rem, "character(s) remaining in the password.")

    return min_specials, rem


def set_min_upper(rem_length):
    """
    Sets the minimum amount of uppercase letters that the password must have.

    :param rem_length: integer representing the remaining length of the password
    :return min_upper: integer representing the minimum amount of uppercase
                       letters in the password
    :return rem: integer representing remaining length of password after
                 minimum number of uppercase letters are taken into account
    """

    print("Please input the minimum amount of uppercase letters that your "
          "password must contain. Alternatively, press ENTER to indicate a "
          "minimum of 1 uppercase letter.")

    # gets the minimum amount of uppercase letters and how many characters
    # remain after considering them
    min_upper, rem = set_min_amt(rem_length)

    print("\nMinimum uppercase letter(s) that the password will contain:",
          min_upper)

    return min_upper, rem


def set_min_amt(rem_length):
    """
    Sets the minimum amount for a specific type of character that the password
    must contain taking into account the remaining length of the password.

    :param rem_length: integer representing the remaining length of the password
    :return min_amt: integer representing the minimum amount of specified
                     characters in the password
    :return rem: integer representing remaining length of password after
                 minimum number of specified characters are taken into account
    """

    # min_amt simply calls get preference with a default of 1
    min_amt = get_preference(ONE)

    # rem gets the calculation of how many more characters can fit on the string
    # considering that min_amt is met
    rem = rem_length - min_amt

    # raises an Exception if no more characters can fit
    if rem < ZERO:
        raise Exception("ERROR: Cannot fit minimum amount of characters in "
                        "password!")

    return min_amt, rem


def set_invalid_chars(pass_length, repeat_limit):
    """
    Sets the characters that must not be included in the password.

    :param pass_length: integer representing length of password
    :param repeat_limit: integer representing maximum number of times a single
                         character can appear back-to-back
    :return invalid: string where each character is not to be included in the
                     password
    """
    # gets a string containing invalid characters
    invalid = input("Please enter characters that cannot be used in the "
                    "password.\n>> ")

    # very unlikely, but if a user tries to make a one character password
    # without allowing it to be repeated enough times, an exception is raised
    if (len(CHAR_POOL) - len(invalid)) == 1 and repeat_limit < pass_length:
        raise Exception("ERROR: Will not have enough characters to produce"
                        "a password!")

    print("\nThe following characters will not be included in the password:",
          " ".join(char for char in invalid))

    return invalid


def get_preference(def_val):
    """
    This function executes a loop that asks for user input that requires a
    numeric value to be given so that a password preference can be known.

    :param def_val: integer representing a default value that is returned if
                    the user does not want to specify a preference
    :return ret_val: integer representing a value of a password preference
    """

    # checks if preference has been set or not
    set_preference = False

    # ret_val initializes to given def_val
    ret_val = def_val

    # while user has not set their preference, the loop runs
    while not set_preference:
        preference_input = input(">> ")

        # EMPTY (""), when a user presses ENTER, is how the program recognizes
        # that the user wants to skip choosing
        if preference_input == EMPTY:
            set_preference = True
        else:
            # try-except-else handles invalid input after it checks for the
            # signal to stop the loop (anything that is not numeric)
            try:
                ret_val = int(preference_input)
            except ValueError:
                print("Please enter a number or press ENTER (default).")
            else:
                set_preference = True

    return ret_val


if __name__ == "__main__":
    generate_password()
